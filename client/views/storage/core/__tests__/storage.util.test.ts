import { testLogger } from "@/lib/testlogger";
import { execSync } from "child_process";
import { readFileSync, writeFileSync } from "fs";
import { generateFileMD5 } from "../storage.util";

// Node.js compatible MD5 function for testing
const generateFileMD5Node = async (filePath: string): Promise<string> => {
  const fileBuffer = readFileSync(filePath);
  const file = new File([fileBuffer], "test.jpg", { type: "image/jpeg" });
  return await generateFileMD5(file);
};

describe("generateFileMD5", () => {
  const testImagePath = "public/templateCover/demo1.jpg";

  test("should generate correct MD5 hash matching md5sum command", async () => {
    // Create test file if it doesn't exist
    try {
      readFileSync(testImagePath);
    } catch {
      testLogger.info("Creating test file...");
      // Create a simple test image (1x1 pixel JPEG)
      const testImageBuffer = Buffer.from([
        0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x00, 0x48, 0x00, 0x48,
        0x00, 0x00, 0xff, 0xdb, 0x00, 0x43, 0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
        0x09, 0x08, 0x0a, 0x0c, 0x14, 0x0d, 0x0c, 0x0b, 0x0b, 0x0c, 0x19, 0x12, 0x13, 0x0f, 0x14, 0x1d, 0x1a, 0x1f,
        0x1e, 0x1d, 0x1a, 0x1c, 0x1c, 0x20, 0x24, 0x2e, 0x27, 0x20, 0x22, 0x2c, 0x23, 0x1c, 0x1c, 0x28, 0x37, 0x29,
        0x2c, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1f, 0x27, 0x39, 0x3d, 0x38, 0x32, 0x3c, 0x2e, 0x33, 0x34, 0x32, 0xff,
        0xc0, 0x00, 0x11, 0x08, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01,
        0xff, 0xc4, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x08, 0xff, 0xc4, 0x00, 0x14, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03,
        0x11, 0x00, 0x3f, 0x00, 0x8a, 0xff, 0xd9,
      ]);
      writeFileSync(testImagePath, testImageBuffer);
    }

    // Get MD5 from md5sum command
    let md5sumResult: string;
    try {
      const md5sumOutput = execSync(`md5sum "${testImagePath}"`, {
        encoding: "utf8",
      });
      md5sumResult = md5sumOutput.split(" ")[0].trim();
      testLogger.info("md5sum result:", md5sumResult);
    } catch (error) {
      testLogger.error("Failed to run md5sum command:", error);
      throw error;
    }

    // Generate MD5 using Node.js compatible function
    const nodeMd5Result = await generateFileMD5Node(testImagePath);
    testLogger.info("Node MD5 result:", nodeMd5Result);

    // Compare results
    expect(nodeMd5Result).toBe(md5sumResult);
  }, 10000); // 10 second timeout for file operations

  test("should generate consistent MD5 for same file", async () => {
    // Create test file if it doesn't exist
    try {
      readFileSync(testImagePath);
    } catch {
      testLogger.info("Creating test file...");
      const testImageBuffer = Buffer.from([
        0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x00, 0x48, 0x00, 0x48,
        0x00, 0x00, 0xff, 0xdb, 0x00, 0x43, 0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
        0x09, 0x08, 0x0a, 0x0c, 0x14, 0x0d, 0x0c, 0x0b, 0x0b, 0x0c, 0x19, 0x12, 0x13, 0x0f, 0x14, 0x1d, 0x1a, 0x1f,
        0x1e, 0x1d, 0x1a, 0x1c, 0x1c, 0x20, 0x24, 0x2e, 0x27, 0x20, 0x22, 0x2c, 0x23, 0x1c, 0x1c, 0x28, 0x37, 0x29,
        0x2c, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1f, 0x27, 0x39, 0x3d, 0x38, 0x32, 0x3c, 0x2e, 0x33, 0x34, 0x32, 0xff,
        0xc0, 0x00, 0x11, 0x08, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01,
        0xff, 0xc4, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x08, 0xff, 0xc4, 0x00, 0x14, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03,
        0x11, 0x00, 0x3f, 0x00, 0x8a, 0xff, 0xd9,
      ]);
      writeFileSync(testImagePath, testImageBuffer);
    }

    // Generate MD5 twice
    const md5Result1 = await generateFileMD5Node(testImagePath);
    const md5Result2 = await generateFileMD5Node(testImagePath);

    expect(md5Result1).toBe(md5Result2);
  });

  test("should generate different MD5 for different files", async () => {
    // Create two different files
    const file1Path = "test1.txt";
    const file2Path = "test2.txt";

    writeFileSync(file1Path, "content1");
    writeFileSync(file2Path, "content2");

    const md5Result1 = await generateFileMD5Node(file1Path);
    const md5Result2 = await generateFileMD5Node(file2Path);

    expect(md5Result1).not.toBe(md5Result2);

    // Cleanup
    try {
      execSync(`rm ${file1Path} ${file2Path}`);
    } catch {
      // Ignore cleanup errors
    }
  });

  test("should handle empty file", async () => {
    const emptyFilePath = "empty.txt";
    writeFileSync(emptyFilePath, "");

    const md5Result = await generateFileMD5Node(emptyFilePath);

    // Empty file MD5 should be d41d8cd98f00b204e9800998ecf8427e
    expect(md5Result).toBe("d41d8cd98f00b204e9800998ecf8427e");

    // Cleanup
    try {
      execSync(`rm ${emptyFilePath}`);
    } catch {
      // Ignore cleanup errors
    }
  });
});
