// This is a build script to be run with Node.js (e.g., using ts-node)
// It reads the Google Fonts JSON and generates typed subset files.

import * as fs from "fs";
import * as path from "path";
import prettier from "prettier";
import { GoogleFontItem } from "../types";
import { logger } from "../../../simpleLogger";
import { processFontList } from "./utils";

// --- Configuration ---
// Define all the paths based on the project root
const SUBSET_DIR = path.resolve(__dirname, "../subset");
const GOOGLE_FONT_DIR = path.resolve(__dirname, "..");
const TYPES_FILE_PATH = path.resolve(
  GOOGLE_FONT_DIR,
  "googleFontSubsetMap.type.ts"
);
const CONST_FILE_PATH = path.resolve(
  GOOGLE_FONT_DIR,
  "googleFontSubsetMap.const.ts"
);
const SUBSET_INDEX_FILE_PATH = path.resolve(SUBSET_DIR, "index.ts");

// Relative import paths for use inside the generated files
const TYPES_IMPORT_PATH = "./types"; // Relative path from GOOGLE_FONT_DIR to types.ts
const SUBSET_IMPORT_PATH = "./subset"; // Relative path from GOOGLE_FONT_DIR to subset dir

// --- Helper Functions ---

/**
 * Sanitizes a subset name (e.g., "latin-ext") into a valid JS variable name (e.g., "latinExt").
 * This is crucial for creating valid import statements.
 */
function sanitizeSubsetForVar(name: string): string {
  // Replaces non-alphanumeric characters with a space, then camelCases
  return name
    .replace(/[^a-zA-Z0-9_]/g, " ")
    .split(" ")
    .map((part, index) => {
      if (!part) return "";
      if (index === 0) return part.toLowerCase();
      return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
    })
    .join("");
}

/**
 * Creates a file, ensuring the directory exists first.
 */
async function writeFile(filePath: string, content: string): Promise<void> {
  try {
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
      // Create the directory recursively if it doesn't exist
      fs.mkdirSync(dir, { recursive: true });
    }

    // Resolve Prettier config
    const prettierConfig = await prettier.resolveConfig(filePath);
    if (!prettierConfig) {
      logger.warn(
        `‚ö†Ô∏è No Prettier config found for ${filePath}. Skipping formatting.`
      );
      fs.writeFileSync(filePath, content, "utf-8");
      return;
    }

    // Format the content using Prettier
    const formattedContent = await prettier.format(content, {
      ...prettierConfig,
      filepath: filePath, // Pass filepath for parser inference
    });

    fs.writeFileSync(filePath, formattedContent, "utf-8");
    logger.log(`‚úÖ Successfully wrote: ${path.basename(filePath)}`);
  } catch (error) {
    logger.error(`‚ùå Error writing file ${filePath}:`, error);
  }
}

// --- File Content Generators ---

/**
 * Stringifies a JavaScript object or array into a TypeScript-like object literal string.
 * Keys are unquoted if they are valid identifiers, and undefined properties are skipped.
 * @param obj The object to stringify.
 * @param indentLevel The current indentation level.
 * @returns The stringified object.
 */
function objectToString<T>(obj: T, indentLevel = 1): string {
  const indent = "  ".repeat(indentLevel);
  const parentIndent = "  ".repeat(indentLevel - 1);

  if (obj === null) return "null";
  if (typeof obj !== "object") {
    // For primitives, use JSON.stringify to handle strings, numbers, etc.
    return JSON.stringify(obj);
  }

  if (Array.isArray(obj)) {
    if (obj.length === 0) return "[]";
    // Stringify each item in the array
    const items = obj
      .map(item => `${indent}${objectToString(item, indentLevel + 1)}`)
      .join(",\n");
    return `[\n${items}\n${parentIndent}]`;
  }

  const objAsRecord = obj as Record<string, unknown>;
  const keys = Object.keys(objAsRecord);
  if (keys.length === 0) return "{}";

  // Stringify each property of the object
  const properties = keys
    .map(key => {
      const value = objAsRecord[key];
      // Skip properties with undefined values (handles optional properties)
      if (value === undefined) {
        return null;
      }

      // Check if the key is a valid JavaScript identifier
      const validIdentifierRegex = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;
      const keyStr = validIdentifierRegex.test(key) ? key : JSON.stringify(key);

      // Recursively stringify the value
      return `${indent}${keyStr}: ${objectToString(value, indentLevel + 1)}`;
    })
    .filter(Boolean) // Remove null entries (for undefined values)
    .join(",\n");

  return `{\n${properties}\n${parentIndent}}`;
}

/**
 * Generates the content for a single subset file (e.g., latin.ts).
 */
function createSubsetFileContent(fontItems: GoogleFontItem[]): string {
  // Relative path from lib/font/google/subset/ to lib/font/google/types.ts
  const importPath = "../types";
  // Stringify the array of font items, with unquoted keys where possible
  const data = objectToString(fontItems, 1);

  return `// This file is auto-generated by generateFontSubsetFiles.ts
import { GoogleFontItem } from '${importPath}';

const data: GoogleFontItem[] = ${data};

export default data;
`;
}

/**
// ...existing code...

/**
 * Generates the content for the main type file (googleFontSubsetMap.type.ts).
 */
function createTypeFileContent(subsetKeys: string[]): string {
  // Create a type entry for each subset key
  const typeEntries = subsetKeys
    .map(key => {
      const varName = sanitizeSubsetForVar(key);
      return `  ${varName}: GoogleFontItem[];`;
    })
    .join("\n");

  return `// This file is auto-generated by generateFontSubsetFiles.ts
import { GoogleFontItem } from '${TYPES_IMPORT_PATH}';

export type GoogleFontSubsetMap = {
${typeEntries}
};
`;
}

/**
 * Generates the content for the main const file (googleFontSubsetMap.const.ts).
 */
function createConstFileContent(subsetKeys: string[]): string {
  // Create the key-value pairs for the const object
  const constEntries = subsetKeys
    .map(key => {
      const varName = sanitizeSubsetForVar(key);
      return `  ${varName}: Subsets.${varName},`;
    })
    .join("\n");

  return `// This file is auto-generated by generateFontSubsetFiles.ts
import { GoogleFontSubsetMap } from './googleFontSubsetMap.type';
import * as Subsets from '${SUBSET_IMPORT_PATH}';

export const googleFontSubsetMap: GoogleFontSubsetMap = {
${constEntries}
};
`;
}

/**
 * Generates the content for the subset index file (subset/index.ts).
 */
function createSubsetIndexFileContent(subsetKeys: string[]): string {
  // Create export statements for each subset file
  const exports = subsetKeys
    .map(key => {
      const varName = sanitizeSubsetForVar(key);
      return `export { default as ${varName} } from './${key}';`;
    })
    .join("\n");

  return `// This file is auto-generated by generateFontSubsetFiles.ts
${exports}
`;
}

// --- Main Function ---

/**
 * Receives the Google Fonts JSON response as a string, processes it,
 * and generates all necessary subset files and type definitions.
 *
 * @param jsonString The raw JSON string from the Google Fonts API.
 */
export async function generateFontSubsetFiles(
  jsonString: string
): Promise<void> {
  logger.log("Starting font subset file generation...");

  // 1. Process the raw string into the map
  const subsetMap = processFontList(jsonString);
  // Get all unique subset names and sort them for consistent file order
  const subsetKeys = Array.from(subsetMap.keys()).sort();

  if (subsetKeys.length === 0) {
    logger.warn(
      "‚ö†Ô∏è No subsets found in the provided JSON. No files will be generated."
    );
    return;
  }

  // 2. Generate and write all individual subset files
  logger.log(
    `Found ${subsetKeys.length} subsets. Generating subset files in ${SUBSET_DIR}...`
  );
  for (const [subsetName, fontItems] of subsetMap.entries()) {
    const subsetFilePath = path.resolve(SUBSET_DIR, `${subsetName}.ts`);
    const fileContent = createSubsetFileContent(fontItems);
    await writeFile(subsetFilePath, fileContent);
  }

  // 3. Generate and write the subset index file
  logger.log(`Generating subset index file: ${SUBSET_INDEX_FILE_PATH}...`);
  const subsetIndexContent = createSubsetIndexFileContent(subsetKeys);
  await writeFile(SUBSET_INDEX_FILE_PATH, subsetIndexContent);

  // 4. Generate and write the main type file
  logger.log(`Generating type file: ${TYPES_FILE_PATH}...`);
  const typeFileContent = createTypeFileContent(subsetKeys);
  await writeFile(TYPES_FILE_PATH, typeFileContent);

  // 5. Generate and write the main const file
  logger.log(`Generating const file: ${CONST_FILE_PATH}...`);
  const constFileContent = createConstFileContent(subsetKeys);
  await writeFile(CONST_FILE_PATH, constFileContent);

  logger.log("\nüéâ Font subset file generation complete.");
}

// --- Example Usage ---
// To run this script:
// 1. Make sure you have 'ts-node' installed (e.g., `npm install -g ts-node`)
// 2. Place `google_fonts.json` in the same directory as this script (the project root).
// 3. Run it from your project root:
//    ts-node ./generateFontSubsetFiles.ts

// This block automatically runs the function if the script is executed directly
(async () => {
  try {
    // Assumes google_fonts.json is at the project root
    const fontJsonPath = path.resolve(__dirname, "google_fonts.json");
    if (fs.existsSync(fontJsonPath)) {
      logger.log("Found 'google_fonts.json', starting generation...");
      const jsonString = fs.readFileSync(fontJsonPath, "utf-8");
      await generateFontSubsetFiles(jsonString);
    } else {
      logger.warn(
        "‚ö†Ô∏è 'google_fonts.json' not found at project root. Script will not run automatically."
      );
      logger.log(
        "You can still import 'generateFontSubsetFiles' and run it manually."
      );
    }
  } catch (error) {
    logger.error("‚ùå Failed to read 'google_fonts.json'.", error);
  }
})();
