import { STUDENT_TABLE_COLUMNS } from "@/components/admin/student/column";
import * as Graphql from "@/graphql/generated/types";
import {
    DateFilterOperation,
    TextFilterOperation,
    DateFilterValue,
} from "@/types/filters";
import { EditableColumn } from "@/types/table.type";

// Helper function to get column definition (can be outside provider)
export const getColumnDef = (
    columnId: keyof Graphql.Student,
): EditableColumn | undefined => {
    return STUDENT_TABLE_COLUMNS.find((col) => col.id === columnId); // No cast needed if col.id is typed correctly
};

// Helper function to get all possible query param keys for a column (outside provider)
export const getQueryParamKeysForColumn = (
    columnId: keyof Graphql.Student,
): (keyof Graphql.StudentsQueryVariables)[] => {
    // This list should contain ALL possible filter keys generated by mapTextFilter/mapDateFilter
    // Keep this updated if you add more filters/columns!
    const textKeys: (keyof Graphql.StudentsQueryVariables)[] = [
        "name",
        "name_not_contains",
        "name_equals",
        "name_not_equals",
        "name_starts_with",
        "name_ends_with",
        "name_is_empty",
        "name_is_not_empty",
        "email",
        "email_not_contains",
        "email_equals",
        "email_not_equals",
        "email_starts_with",
        "email_ends_with",
        "email_is_empty",
        "email_is_not_empty",
        "phone_number", // Add specific phone filters if schema supports more than 'like'
    ];
    const dateKeys: (keyof Graphql.StudentsQueryVariables)[] = [
        "created_at",
        "created_at_not",
        "created_at_from",
        "created_at_to",
        "created_at_after",
        "created_at_before",
        "created_at_on_or_after",
        "created_at_on_or_before",
        "created_at_is_empty",
        "created_at_is_not_empty",
        "birth_date",
        "birth_date_not",
        "birth_date_from",
        "birth_date_to",
        "birth_date_after",
        "birth_date_before",
        "birth_date_on_or_after",
        "birth_date_on_or_before",
        "birth_date_is_empty",
        "birth_date_is_not_empty",
    ];
    // Add keys for other types (enum, etc.)
    // const enumKeys: (keyof Graphql.StudentsQueryVariables)[] = [
    //     "gender",
    //     "nationality",
    // ];

    switch (columnId) {
        case "name":
        case "email":
        case "phone_number": // Assuming phone is treated as text for filtering
            return textKeys.filter((k) => k.startsWith(columnId)); // Return only relevant text keys
        case "created_at":
            return dateKeys.filter((k) => k.startsWith("created_at"));
        case "date_of_birth":
            return dateKeys.filter((k) => k.startsWith("birth_date"));
        case "gender":
            return ["gender"]; // Only direct equality filter
        case "nationality":
            return ["nationality"]; // Only direct equality filter
        // Add cases for other filterable columns
        default:
            return [];
    }
};

// Define mappings for text operations to GraphQL query parameter suffixes and value formatting
export const textOperationConfig: {
    [key in TextFilterOperation]?: {
        // Suffix to append to columnId (e.g., "_equals", "_not_contains")
        // Empty string "" often means the base column name (e.g., for CONTAINS)
        suffix: string;
        // Function to format the value if needed (e.g., add wildcards)
        formatValue?: (val: string) => string;
        // Does this operation require a boolean value instead of string?
        isBooleanOp?: boolean;
    };
} = {
    [TextFilterOperation.CONTAINS]: {
        suffix: "",
        formatValue: (val) => `%${val}%`,
    },
    [TextFilterOperation.NOT_CONTAINS]: {
        suffix: "_not_contains",
        formatValue: (val) => `%${val}%`,
    },
    [TextFilterOperation.EQUALS]: { suffix: "_equals" },
    [TextFilterOperation.NOT_EQUALS]: { suffix: "_not_equals" },
    [TextFilterOperation.STARTS_WITH]: {
        suffix: "_starts_with",
        formatValue: (val) => `${val}%`,
    },
    [TextFilterOperation.ENDS_WITH]: {
        suffix: "_ends_with",
        formatValue: (val) => `%${val}`,
    },
    [TextFilterOperation.IS_EMPTY]: { suffix: "_is_empty", isBooleanOp: true },
    [TextFilterOperation.IS_NOT_EMPTY]: {
        suffix: "_is_not_empty",
        isBooleanOp: true,
    },
};

// Helper to map a single text filter operation to query params (outside provider)
export const mapTextFilter = (
    columnId: keyof Graphql.Student,
    op: TextFilterOperation,
    value: string | boolean,
): Partial<Graphql.StudentsQueryVariables> => {
    const params: Partial<Graphql.StudentsQueryVariables> = {};
    const config = textOperationConfig[op];

    // If operation is not configured, return empty params
    if (!config) {
        console.warn(`Unsupported text filter operation: ${op}`);
        return params;
    }

    // Validate value type based on operation config
    const requiresBoolean = config.isBooleanOp ?? false;
    if (requiresBoolean && typeof value !== "boolean") {
        console.warn(`Operation ${op} requires a boolean value.`);
        return params;
    }
    if (!requiresBoolean && typeof value !== "string") {
        console.warn(`Operation ${op} requires a string value.`);
        return params;
    }

    // Handle special case: phone_number might only support CONTAINS
    if (columnId === "phone_number") {
        if (op === TextFilterOperation.CONTAINS && typeof value === "string") {
            params.phone_number = `%${value}%`;
        } else if (op !== TextFilterOperation.CONTAINS) {
            console.warn(
                `Operation ${op} might not be supported for phone_number.`,
            );
        }
        return params; // Return early for phone_number
    }

    // Construct the parameter key
    // Use base columnId if suffix is empty (common for CONTAINS)
    const paramKey =
        `${columnId}${config.suffix}` as keyof Graphql.StudentsQueryVariables;

    // Assign value based on type
    if (requiresBoolean) {
        // Only assign if the boolean value is true
        if (value === true) {
            params[paramKey] = true;
        }
    } else {
        // Format string value if a format function exists, otherwise use raw value
        const stringValue = value as string; // Type assertion is safe due to earlier check
        params[paramKey] = config.formatValue
            ? config.formatValue(stringValue)
            : stringValue;
    }

    return params;
};

// Helper to format date for MySQL datetime format
export const formatDate = (
    date: string | Date | null | undefined,
): string | undefined => {
    if (!date) return undefined;

    try {
        // Convert to Date if it's a string
        const dateObj = typeof date === "string" ? new Date(date) : date;

        // Format as YYYY-MM-DD HH:mm:ss
        return dateObj.toISOString().slice(0, 19).replace("T", " ");
    } catch {
        return undefined; // Handle invalid date object
    }
};

// Helper to map a single date filter operation to query params
export const mapDateFilter = (
    columnId: keyof Graphql.Student,
    op: DateFilterOperation,
    value: DateFilterValue | string | boolean,
): Partial<Graphql.StudentsQueryVariables> => {
    const params: Partial<Graphql.StudentsQueryVariables> = {};

    // Handle boolean operations (is_empty, is_not_empty)
    if (
        op === DateFilterOperation.IS_EMPTY ||
        op === DateFilterOperation.IS_NOT_EMPTY
    ) {
        const suffix =
            op === DateFilterOperation.IS_EMPTY ? "_is_empty" : "_is_not_empty";
        const paramKey =
            `${columnId}${suffix}` as keyof Graphql.StudentsQueryVariables;
        params[paramKey] = true;
        return params;
    }

    // Handle date range operations (between)
    if (
        op === DateFilterOperation.BETWEEN &&
        typeof value === "object" &&
        value !== null
    ) {
        const { from, to } = value;
        if (from) {
            const fromKey =
                `${columnId}_from` as keyof Graphql.StudentsQueryVariables;
            params[fromKey] = formatDate(from);
        }
        if (to) {
            const toKey =
                `${columnId}_to` as keyof Graphql.StudentsQueryVariables;
            params[toKey] = formatDate(to);
        }
        return params;
    }

    // Handle single date operations
    let suffix: string;
    switch (op) {
        case DateFilterOperation.IS_NOT:
            suffix = "_not";
            break;
        case DateFilterOperation.IS_BEFORE:
            suffix = "_before";
            break;
        case DateFilterOperation.IS_AFTER:
            suffix = "_after";
            break;
        case DateFilterOperation.IS_ON_OR_BEFORE:
            suffix = "_on_or_before";
            break;
        case DateFilterOperation.IS_ON_OR_AFTER:
            suffix = "_on_or_after";
            break;
        case DateFilterOperation.IS:
            suffix = "";
            break;
        default:
            console.warn(`Unsupported date filter operation: ${op}`);
            return params;
    }

    // For single date operations, we use the 'from' value if available
    if (typeof value === "object" && value?.from) {
        const paramKey =
            `${columnId}${suffix}` as keyof Graphql.StudentsQueryVariables;
        params[paramKey] = formatDate(value.from);
    } else if (typeof value === "string") {
        // Handle direct date string value
        const paramKey =
            `${columnId}${suffix}` as keyof Graphql.StudentsQueryVariables;
        params[paramKey] = formatDate(value);
    }

    return params;
};
